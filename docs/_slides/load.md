---
---

## Load Data

We will use the function `read.csv()` to load data from a Comma Separated Value
file. The essential argument for the function to read in data is the path to the
file, other optional arguments adjust how the file is read.

Additional file types can be read in using `read.table()`; in fact, `read.csv()`
is a simple wrapper for the `read.table()` function having set some default
values for some of the optional arguments (e.g. `sep = ","`).
{:.notes}

===

Use the assignment operator "<-" to read data into a variable for
subsequent operations.

Type `read.csv(` into the editor and then press **tab** to see what arguments
this function takes. Hovering over each item in the list will show a description
of that argument from the help documentation about that function. Specify the
values to use for an argument using the syntax `name = value`.
{:.notes}



~~~r
storm <- read.csv('data/StormEvents.csv')
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


===

Question
: How does `read.csv` determine the field names?

Answer
: {:.fragment} The `read.csv` command assumes the first row in the file contains
column names. Look at `?read.csv` to see the default `header = TRUE` argument.
What exactly that means is described down in the "Arguments" section.

===

After reading in the "StormEvents.csv" file, you can explore what types of data
are in each column with the `str` function, short for "structure".



~~~r
> str(storm)
~~~
{:title="Console" .input}


~~~
'data.frame':	100 obs. of  42 variables:
 $ BEGIN_YEARMONTH  : int  200604 200601 200601 200601 200601 200601 200601 200601 200601 200601 ...
 $ BEGIN_DAY        : int  7 1 1 1 1 30 30 28 28 28 ...
 $ BEGIN_TIME       : int  1515 0 0 0 0 500 500 800 1400 800 ...
 $ END_YEARMONTH    : int  200604 200601 200601 200601 200601 200601 200601 200601 200601 200601 ...
 $ END_DAY          : int  7 31 31 31 31 31 31 29 29 29 ...
 $ END_TIME         : int  1515 2359 2359 2359 2359 1400 1400 1300 500 1600 ...
 $ EPISODE_ID       : int  207534 202408 202409 202409 202409 202394 202394 202395 202396 202397 ...
 $ EVENT_ID         : int  5501658 5482479 5482480 5482481 5482482 5482324 5482325 5482326 5482327 5482328 ...
 $ STATE            : Factor w/ 19 levels "ALASKA","ARKANSAS",..: 6 3 17 17 17 3 3 3 3 3 ...
 $ STATE_FIPS       : int  18 8 49 49 49 8 8 8 8 8 ...
 $ YEAR             : int  2006 2006 2006 2006 2006 2006 2006 2006 2006 2006 ...
 $ MONTH_NAME       : Factor w/ 4 levels "April","February",..: 1 3 3 3 3 3 3 3 3 3 ...
 $ EVENT_TYPE       : Factor w/ 14 levels "Avalanche","Coastal Flood",..: 11 4 4 4 4 14 14 13 14 14 ...
 $ CZ_TYPE          : Factor w/ 2 levels "C","Z": 1 2 2 2 2 2 2 2 2 2 ...
 $ CZ_FIPS          : int  51 12 23 29 24 4 13 13 5 4 ...
 $ CZ_NAME          : Factor w/ 63 levels "ALAMANCE","ANIMAS RIVER BASIN",..: 27 63 20 9 19 21 23 23 60 21 ...
 $ WFO              : Factor w/ 13 levels "AFC","DTX","GJT",..: 9 3 3 3 3 3 3 3 3 3 ...
 $ BEGIN_DATE_TIME  : Factor w/ 53 levels "01-JAN-06 00:00:00",..: 14 1 1 1 1 52 52 49 50 49 ...
 $ CZ_TIMEZONE      : Factor w/ 6 levels "AST","CST","CST-6",..: 2 5 5 5 5 5 5 5 5 5 ...
 $ END_DATE_TIME    : Factor w/ 55 levels "01-JAN-06 09:20:00",..: 13 55 55 55 55 54 54 51 49 52 ...
 $ INJURIES_DIRECT  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ INJURIES_INDIRECT: int  0 0 0 0 0 0 0 0 0 0 ...
 $ DEATHS_DIRECT    : int  0 0 0 0 0 0 0 0 0 0 ...
 $ DEATHS_INDIRECT  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ DAMAGE_PROPERTY  : Factor w/ 6 levels "0","0.00K","200K",..: 5 NA NA NA NA NA NA NA NA NA ...
 $ DAMAGE_CROPS     : Factor w/ 3 levels "0","0.00K","UNKNOWN": NA NA NA NA NA NA NA NA NA NA ...
 $ SOURCE           : Factor w/ 14 levels "AMATEUR RADIO",..: 7 8 8 8 8 2 2 2 14 2 ...
 $ MAGNITUDE        : num  61 NA NA NA NA NA NA NA NA NA ...
 $ MAGNITUDE_TYPE   : Factor w/ 2 levels "EG","MG": 1 NA NA NA NA NA NA NA NA NA ...
 $ BEGIN_RANGE      : int  4 NA NA NA NA NA NA NA NA NA ...
 $ BEGIN_AZIMUTH    : Factor w/ 8 levels "E","N","NE","NW",..: 1 NA NA NA NA NA NA NA NA NA ...
 $ BEGIN_LOCATION   : Factor w/ 20 levels "ATLANTA","COLUMBUS",..: 13 NA NA NA NA NA NA NA NA NA ...
 $ END_RANGE        : int  NA NA NA NA NA NA NA NA NA NA ...
 $ END_AZIMUTH      : Factor w/ 7 levels "E","N","NE","NW",..: NA NA NA NA NA NA NA NA NA NA ...
 $ END_LOCATION     : Factor w/ 19 levels "ATLANTA","COLUMBUS",..: 13 NA NA NA NA NA NA NA NA NA ...
 $ BEGIN_LAT        : num  38.4 NA NA NA NA ...
 $ BEGIN_LON        : num  -87.5 NA NA NA NA ...
 $ END_LAT          : num  38.3 NA NA NA NA ...
 $ END_LON          : num  -87.3 NA NA NA NA ...
 $ EPISODE_NARRATIVE: Factor w/ 37 levels "3 CHICKEN HOUSES DESTROYED.",..: NA 36 35 35 35 7 7 37 15 8 ...
 $ EVENT_NARRATIVE  : Factor w/ 6 levels "1.3 inches of rain fell in 30 minutes.",..: 2 NA NA NA NA NA NA NA NA NA ...
 $ DATA_SOURCE      : Factor w/ 2 levels "CSV","PDS": 2 2 2 2 2 2 2 2 2 2 ...
~~~
{:.output}


===

The data viewer, opened with `View` or the spreadsheet icon a data frame's record
in the Environment, is useful despite not being a full spreadsheet application.



~~~r
> View(storm)
~~~
{:title="Console" .no-eval .input}


===

Missing data, as interpreted by the `read.csv` function, is controlled by the
`na.strings` argument. Override the default value of `'NA'` with a character
vector.

You often need to specify multiple strings to interpret as missing values, such
as `na.strings = c("missing", "no data", "< 0.05 mg/L", "XX")`.
{:.notes}



~~~r
storm <- read.csv(
  'data/StormEvents.csv',
  na.strings = c('NA', 'UNKNOWN'))
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


