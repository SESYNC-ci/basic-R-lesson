---
title: "Quickstart to R"
author: "Kelly Hondula"
output:
  html_document:
    toc: true
    toc_depth: 1
---

# What is R?

* R is a programming language for statistical computing and graphics
* Easy to handle multiple types of data in the same object (data frames) including missing values
* Easy to use in RStudio IDE
* Large user community especially within ecology

# Types of objects

Objects in R can be described according to these categories:

| Dimensions    | Homogeneous |  Heterogeneous |
|----|----|---|
| 1d |  Vector |	List|
| 2d |	Matrix |	Data frame |
| nd |	Array |

## Vectors 

Vectors are the basic data structure in R. They contain a list of things in order and all of the same type of element, such as numbers. Create a vector by combining elements together using the function `c()`. Use the operator `:` for a sequence of numbers otherwise separate them with commas. 

The four common types of vectors are: 

* logical
* integer
* numeric
* character 

All elements of an vector must be the same type, so when you attempt to combine different types they will be coerced to the most flexible type. Types from least to most flexible are: logical, integer, double, and character. 

Character data in base R are read in as a factor by default, ie. stored as integers. Data that are strictly positive whole numbers are stored as integers. 

> Use `c()` and `:` to create some vectors

```{r}
c(3,4,5,6,7)
c(3:7)
```

Store vectors in memory by using the **assignment operator** `<-`. Then you can refer to the items in that vecotr by using its name. Use bracket notation to refer to a selected item or selection of items in that list. 

```{r}
mynumbers <- c(1:10) # store vector with assignment operator
mynumbers
mynumbers[3]
```

## Factors

A factor is a vector that can contain only predefined values, and is used to store categorical data. Factors are built on top of integer vectors using two attributes: the class(), “factor”, which makes them behave differently from regular integer vectors, and the levels(), which defines the set of allowed values. 

We can make a column a factor with the as.factor() function. Use `as.factor()` to change the month column to a factor and see how the result of the summary function changes

```{r, eval=FALSE}
surveys$month <- as.factor(surveys$month)
summary(surveys)
```


## Data frames

Data frames are 2-dimensional and can contain heterogenous data like numbers in one column and categories in another. Othe

Data frames are spreadsheet-like data strcutures in R. Each column of a data frame is a vector. 
A data.frame is one of the most commonly used objects in R. Just think of a data.frame like a table, or a spreadsheet, with rows and columns and numbers, text, etc. in the cells. A very special thing about the data.frame in R is that it can handle multiple types of data - that is, each column can have a different type. 

> Make a vector using `c()` but now put each item in the list in quotes. This means it will be interpreted as a **string** or word, instead of a number.  

```{r}
animals <- c("pig", "dog", "cat", "bunny") 
```

> Combine `x` and `animals` into a **data frame** with the aptly named function `data.frame()`. Note the period between the words. Store your data frame as an object called `my_df`.

```{r, eval=FALSE}
my_df <- data.frame(animals, x)
my_df
```

Getting to know your data frame

| function | returns |
|----------|---------|
| `dim()` | dimensions |
| `nrow()` | number of rows |
| `ncol()` | number of columns |
| `names()` | (column) names |
| `str()` | structure |
| `summary()` | summary info |
| `head()` | shows beginning rows |


## Lists

Lists like vectors but their elements can be of any type, including another list! You construct lists by using `list()` instead of `c()`. 

`c()` will combine several lists into one. If given a combination of atomic vectors and lists, `c()` will coerce the vectors to lists before combining them. 

> Compare the results of `list()` and `c()`

```{r}
x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))
str(x)
str(y)
```


# Subsetting

R has powerful subsetting capabilities that can be accessed very concisely using square brackets. Just like vectors, data frames can be subset and manipulated with square brackets The square brackets work as follows: anything before the comma refers to the rows that will be selected, anything after the comma refers to the number of columns that should be returned.

Note that in R the first element of a vector has an index of 1. 

Some ways to subset vectors with bracket notation `[]`. 

1. __positive integers__: return elements at the specified positions
2. __Negative integers__: omit elements at the specified positions
3. __Logical vectors__: select elements where the corresponding logical value is TRUE
4. __Nothing__: returns the original vector (more useful for dataframes)

# Review: Important symbols

Assign a value to an object with the assignment operator using the syntax `objectName <- value`. Object names in R cannot start with a number.

```{r}
x <- 1+2
x
```


| Symbol | Meaning |
| -------|---------|
| `?` | get help |
| `c()` | combine |
| `#` | comment | 
| `:` | sequence |
| `<-` | assignment |
| `[ ]` | selection |

> Exercise: Fix each of the following common data frame subsetting errors:

```{r, eval = FALSE}
plots[plots$plot_id = 4, ]
plots[-1:4, ]
plots[plots$plot_id <= 5]
plots[plots$plot_id == 4 | 6, ]
```

## Subsetting with $ and double brackets

* There are two other subsetting operators: `[[` and `$`. `[[` is similar to `[`, except it can only return a single value and it allows you to pull pieces out of a list. `$` is a useful shorthand for `[[` combined with character subsetting. 


## Subsetting and assignment

All subsetting operators can be combined with assignment to modify selected values of the input vector.

With lists, you can use subsetting + assignment + `NULL` to remove components from a list. To add a literal `NULL` to a list, use `[` and `list(NULL)`. Notice the difference in the structure of `x` and `y`:

```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)
```


```{r}
y <- list(a = 1)
y["b"] <- list(NULL)
str(y)
```

## Selecting rows based on a condition

Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame. 

`subset()` is a specialised shorthand function for subsetting data frames, and saves some typing because you don’t need to repeat the name of the data frame. 
  



# Load data into R


We will use the function `read.csv()` that reads in a file by passing it the location of the file. The general syntax for the functions to read in data are to give the path to the file name, and then supply optinal additional arguments as necessary like specifying the type of data in each column. Type a comma after `read.csv(` and then press **tab** to see what arguments that this function takes. Hovering over each item in the list will show a description of that argument from the help documentation about that function. Specify the values to use for an argument using the syntax `name = value`. 

``` {r}
read.csv(file="/nfs/public-data/ci-spring2016/Data/plots.csv")
```

> Use the assignment operator "<-" to store that data in memory and work with it

``` {r}
plots <- read.csv(file="/nfs/public-data/ci-spring2016/Data/plots.csv")
surveys <- read.csv(file="/nfs/public-data/ci-spring2016/Data/surveys.csv")
``` 

You can specify what indicates missing data in the read.csv function using either `na.strings = "NA"` or `na = "NA"`. You can also specify multiple things to be interpreted as missing values, such as `na.strings = c("missing", "no data", "< 0.05 mg/L", "XX")`.

After reading in the Surveys and Plots csv files, let's explore what types of data are in each column and what kind of structure your data has. 


``` {r}
str(plots)
summary(plots)

str(surveys)
summary(surveys)
``` 

Each column in a data frame can be referred to using the `$` operator and the data frame name and the column name. `surveys$record_id` refers to the record_id column in the surveys data frame.

# Write a custom function

lots of basic math functions can be performed using operators and names like `max` `range` `sin` `log` and `sqrt`

# Statistics


# Writing your own functions

Functions enable easy reuse within a project, helping you not to repeat yourself. If you see blocks of similar lines of code through your project, those are usually candidates for being moved into functions.

If your calculations are performed through a series of functions, then the project becomes more modular and easier to change. This is especially the case for which a particular input always gives a particular output.

Three components of functions

* **name**: descriptive name that does not start with a number
* __body__: the code inside the function
* __arguments__: control how you can call the function


A function needs to have a name, probably at least one argument (although it doesn’t have to), and a body of code that does something. At the end it usually should (although doesn’t have to) return an object out of the function. The important idea behind functions is that objects that are created within the function are local to the environment of the function – they don’t exist outside of the function. But you can “return” the value of the object from the function, meaning pass the value of it into the global environment.

```{r}
myfunction <- function(x) {
  # do something to x here
  # return a value of interest
}
```

The base R language does not have a function to calculate the standard error of the mean. Since this is a common statistical value of interest, let's write a function to calculate the standard error. Recall that the standard error is calculated as the square root of the variance over the sample size. 

The 3 functions needed for the standard error calculation are `sqrt` for square root, `var` for variance, and `length` for sample size. Calculate the standard error of the `wgt` column using these three functions. 

```{r}
sqrt(var(surveys$weight)/length(surveys$weight))
```

We can generalize the calculation that we made by storing it as a **function** called stderr. The calculation that we made above goes into the **body** of the function. 

```{r}
stderr <- function(x){
  # this function returns the standard error of the mean
  sqrt(var(x)/length(x))
  }
```

> Exercise: Calculate the standard error of the mean for the subset of surveys done in 1990. Calculate the standard error of the mean for all surveys done in the month of June

# Base plotting

plotting and graphical parameters

# Base plotting

The `plot()` function is the most basic plotting function. It is polymorphic, ie. it uses the information you give it to determine what kind of plot to make. 

## Scatterplots

basic syntax is `plot(x, y)` or `plot(y ~ x)`

``` {r}
plot(surveys$month, surveys$weight)
plot(surveys$year, surveys$weight)
plot(surveys$year, log(surveys$weight))

``` 

## Histograms

``` {r}
hist(surveys$weight)
hist(log(surveys$weight))
``` 

## Boxplots

> Use a boxplot to compare the number of species seen each year. 

``` {r}
par(mfrow=c(1,1))
boxplot(surveys$weight ~ surveys$year)
boxplot(surveys$weight ~ surveys$month)
boxplot(log(surveys$weight) ~ surveys$year)
``` 

## Graphical parameters

par()

* adjust line types, plotting characters, cex, x and y labels
* plot different factors/types in different colors

Multi-panel plots can be made by changing the graphical parameters with the `par()` function. 

``` {r}
surveys1990 <- subset(surveys, year == 1990)
surveys1996 <- subset(surveys, year == 1996)

par(mfrow=c(1,2))
hist(log(surveys1990$weight))
hist(log(surveys1996$weight))

``` 



# Additional resources and references

* [Jenny Bryan's Stat 545 class materials index of topics](http://stat545-ubc.github.io/topics.html) from which some of this material was adopted
* [keyboard shortcuts in RStudio](https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts)
* [R Graph catalog](http://shiny.stat.ubc.ca/r-graph-catalog/)
* [Intro R Shiny app](http://www.intro-stats.com/)

